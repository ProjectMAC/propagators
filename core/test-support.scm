(declare (usual-integrations))

(define (->significant-figures places number)
  (define (round-down? digit-trail)
    (or (null? digit-trail)
	(memq (car digit-trail) '(#\0 #\1 #\2 #\3 #\4))
	(and (eq? (car digit-trail) #\.)
	     (or (null? (cdr digit-trail))
		 (memq (cadr digit-trail) '(#\0 #\1 #\2 #\3 #\4))))))
  (define (decimal-increment reversed-digit-list)
    (cond ((null? reversed-digit-list)
	   '(#\1))
	  ((eq? (car reversed-digit-list) #\.)
	   (cons (car reversed-digit-list)
		 (decimal-increment (cdr reversed-digit-list))))
	  ((eq? (car reversed-digit-list) #\9)
	   (cons #\0 (decimal-increment (cdr reversed-digit-list))))
	  (else 
	   (cons (integer->char (+ 1 (char->integer (car reversed-digit-list))))
		 (cdr reversed-digit-list)))))
  (let ((digits (string->list (number->string number))))
    (let loop ((result '())
	       (more-digits digits)
	       (places places)
	       (zeros-matter? #f))
      (cond ((null? more-digits)
	     (string->number (list->string (reverse result))))
	    ;; TODO This relies on being after the decimal point
	    ((= places 0)
	     (string->number
	      (list->string
	       (reverse
		(if (round-down? more-digits)
		    result
		    (decimal-increment result))))))
	    ((eq? #\. (car more-digits))
	     (loop (cons (car more-digits) result)
		   (cdr more-digits)
		   places
		   zeros-matter?))
	    ((eq? #\0 (car more-digits))
	     (loop (cons (car more-digits) result)
		   (cdr more-digits)
		   (if zeros-matter? (- places 1) places)
		   zeros-matter?))
	    (else
	     (loop (cons (car more-digits) result)
		   (cdr more-digits)
		   (- places 1)
		   #t))))))

(define-method generic-match ((pattern <vector>) (object <vector>))
  (reduce boolean/and #t (map generic-match
			      (vector->list pattern)
			      (vector->list object))))

(define-method generic-match ((pattern <pair>) (object <pair>))
  (and (generic-match (car pattern) (car object))
       (generic-match (cdr pattern) (cdr object))))

(define-method generic-match ((pattern <inexact>) (object <inexact>))
  (or (= pattern object)
      (= pattern (->significant-figures 5 object))))

;;; Some propagator functions used in the test suite.

(define (fahrenheit->celsius f c)
  (let ((thirty-two (make-cell))
	(f-32 (make-cell))
	(five (make-cell))
	(c*9 (make-cell))
	(nine (make-cell)))
    ((constant 32) thirty-two)
    ((constant 5) five)
    ((constant 9) nine)
    (subtractor f thirty-two f-32)
    (multiplier f-32 five c*9)
    (divider c*9 nine c)))

(define (sum x y total)
  (adder x y total)
  (subtractor total x y)
  (subtractor total y x))

(define (product x y total)
  (multiplier x y total)
  (divider total x y)
  (divider total y x))

(define (quadratic x x^2)
  (squarer x x^2)
  (sqrter x^2 x))

(define (fahrenheit-celsius f c)
  (let ((thirty-two (make-cell))
	(f-32 (make-cell))
	(five (make-cell))
	(c*9 (make-cell))
	(nine (make-cell)))
    ((constant 32) thirty-two)
    ((constant 5) five)
    ((constant 9) nine)
    (sum thirty-two f-32 f)
    (product f-32 five c*9)
    (product c nine c*9)))

(define (celsius-kelvin c k)
  (let ((many (make-cell)))
    ((constant 273.15) many)
    (sum c many k)))

(define (fall-duration t h)
  (let ((g (make-cell))
        (one-half (make-cell))
        (t^2 (make-cell))
        (gt^2 (make-cell)))
    ((constant (make-interval 9.789 9.832)) g)
    ((constant (make-interval 1/2 1/2)) one-half)
    (quadratic t t^2)
    (product g t^2 gt^2)
    (product one-half gt^2 h)))

(define (similar-triangles s-ba h-ba s h)
  (let ((ratio (make-cell)))
    (product s-ba ratio h-ba)
    (product s ratio h)))

(define (heron-step x g h)
  (compound-propagator (list x g)       ; inputs
    (lambda ()                          ; how to build
      (let ((x/g (make-cell))
            (g+x/g (make-cell))
            (two (make-cell)))
        (divider x g x/g)
        (adder g x/g g+x/g)
        ((constant 2) two)
        (divider g+x/g two h)))))

(define (sqrt-iter x g answer)
  (compound-propagator (list x g)
    (lambda ()
      (let ((done (make-cell))
            (x-if-not-done (make-cell))
            (g-if-done (make-cell))
            (g-if-not-done (make-cell))
            (new-g (make-cell))
            (recursive-answer (make-cell)))
        (good-enuf? x g done)
        (conditional-writer done x (make-cell) x-if-not-done)
        (conditional-writer done g g-if-done g-if-not-done)
        (heron-step x-if-not-done g-if-not-done new-g)
        (sqrt-iter x-if-not-done new-g recursive-answer)
        (conditional done g-if-done recursive-answer answer)))))

(define (sqrt-network x answer)
  (compound-propagator x
    (lambda ()
      (let ((one (make-cell)))
        ((constant 1.0) one)
        (sqrt-iter x one answer)))))

(define (good-enuf? x g done)
  (compound-propagator (list x g)
    (lambda ()
      (let ((g^2 (make-cell))
            (eps (make-cell))
            (x-g^2 (make-cell))
            (ax-g^2 (make-cell)))
        ((constant .00000001) eps)
        (multiplier g g g^2)
        (subtractor x g^2 x-g^2)
        (absolute-value x-g^2 ax-g^2)
        (<? ax-g^2 eps done)))))
