Post-monadic progress:
- Squeeze out uses of nary-unpacking where binary-mapping will suffice
  - Check each use of propagatify for using the right wrapper.
  - What's going on with (nary-unpacking (ineq-enforcer-func direction))?
  - What's going on with (v-c-i/o-unpacking (nary-unpacking f))?
  - Is it true that switch and accessors are the only uses left?
- Review the existing code in light of the understanding that
  autocomposition doesn't work; document map of which partial
  information structures are implemented; test them?
- Relate the results of that review to carrying cells;
- Implement closures (dammit!)
- Math about what monads become in the new world order?
  - With the understanding that I am not trying to automatically compose them
- Return to electricity

Now:
- Nice pictures, data of me, Gerry, David; add Guy?
- Link to propagator page from the front page
- Link to propagator paper list?
- Do I want to link to the news article about me?

Pre-release:
- Profile the system in MIT Scheme 9.0.1 or later
- Draw pictures of the electrical circuits?
- Produce reference documentation of important program elements
  - Take the debugging utilities out of the introductory guide
- Proofread README; abstract "developer guide" from it?
- Refer to test-manager documentation
- Put the programmer guide on the web
- Cross-link propagator-oriented and Scheme-Propagators in the
  propagator guide and the ad

Massage:
- Tease apart Scmutils stuff from Scheme stuff?
- Extract draw.scm & co. into support/; abstract propagator stuff away from it?
- How many examples do I want to rewrite in expression style?
- Concept diagram?  (All the way down to test-manager/, MIT Scheme,
  and Scheme?)  With concept dependencies, "how to know what
  concept(s) you are looking at", "how to know what concept(s) you
  need for task X".
- rake workbook (lots of enscript, with some file names and chapter names)
- rake stats (count files, lines, words, syntactic tokens, etc)
- Are there more example networks to be extracted out of the unit tests?
- Write decent progress reporting for all the examples?
  - solve-puzzle returns the answer and is suitable for a silent test
  - do-puzzle has wallpaper and is suitable for the repl
- Is voltage-divider* an example or an extension or a test of an extension?
  - Is electric-parts.scm an extension or an example?  bridge-rectifier?
- Can I get away with
  (in-test-group mumble (load "mumble-test"))
  being the standard way to do things?
  Can I abstract that?
  - Automatically localizes everything in the test files
- Read through all the code from the top

- Make emacs highlight rtd:mumble?
- fail-all, for-each-consistent-state, and map-consistent-states are
  only used by the bridge rectifier.  (Which might be an example
  anyway).  But they are in principle more general.  Where should they
  go?
- Where does the stuff in extensions/test-utils.scm belong?
  - Where do random define-method calls go?
- Look through the file structure of the tests again?
- Does defhandler want to become define-handler?

- Convert cells and propagators not to just be procedures?
  Then I can type tag them nicely, and define custom unparser
  methods for them.
